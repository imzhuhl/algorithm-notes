## 基础

### 最长公共子序列

题目见 [leetcode 1143](https://leetcode-cn.com/problems/longest-common-subsequence/)

给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列的长度。若这两个字符串没有公共子序列，则返回 0。

>  一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。
> 例如，"ace" 是 "abcde" 的子序列，但 "aec" 不是 "abcde" 的子序列。两个字符串的「公共子序列」是这两个字符串所共同拥有的子序列。

示例：

```
输入: text1 = "abcde", text2 = "ace"
输出: 3

输入: text1 = "abc", text2 = "def"
输出: 0
```

**思路**：

需要找到当前状态和之前状态之间的递推关系，用 dp 表示状态数组。

* 例如对于样例 abcde 和 ace 的解，发现两个字符串的最后一个都是 e。因此对于 abcd 和 ac 的最长公共子序列，只要加上 e 就是 abcde 和 ace 的解，即 `dp[i,j] = dp[i-1][j-1]`
* 如果当前状态的两个字符不相同，例如 abcd 和 abdc。发现 abcd 和 abd 的最长子序列是 3，abd 末尾加字符 c 不改变结果。另一方面，abc 和 abdc 的最长子序列是 3，abc 末尾补上 d 不改变结果。因此当前状态取决于 `dp[i-1, j]` 和 `dp[i, j-1]`

综上，判断逻辑如下：

```python
if text1[i-1] == text2[j-1]:
    dp[i][j] = dp[i-1][j-1] + 1
else:
    dp[i][j] = max(dp[i-1][j], dp[i][j-1])
```

代码见 [1143](./最长公共子序列/1143.py)






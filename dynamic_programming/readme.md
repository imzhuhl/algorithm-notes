# 基础

## 最长公共子序列

**例题**： [leetcode 1143](https://leetcode-cn.com/problems/longest-common-subsequence/)

给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列的长度。若这两个字符串没有公共子序列，则返回 0。

>  一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。
> 例如，"ace" 是 "abcde" 的子序列，但 "aec" 不是 "abcde" 的子序列。两个字符串的「公共子序列」是这两个字符串所共同拥有的子序列。

示例：

```
输入: text1 = "abcde", text2 = "ace"
输出: 3

输入: text1 = "abc", text2 = "def"
输出: 0
```

代码见 `exercise/1143`

# 背包

## 01背包

**典型例题**：

有 n 个物品和一个总承重量为 W 的背包，每个物品有重量 $ w_i $ 和价值 $ v_i $ 两种属性，要求选若干物品放入背包使背包中物品的总价值最大且背包中物品的总重量不超过背包的承重。

**思路**：

假设考虑前 $i$ 个物品和 $j$ 容量时的背包最大价值为 $dp(i,j)$ ，考虑递推关系，对于当前最大价值，有两种情况：

* 不放第 $i$ 个物品，因此与前 $i-1$ 个物品的最大价值相同， $dp(i,j) = dp(i-1,j)$
* 放第 $i$ 个物品，因此价值为前 $i-1$ 个物品在背包重量为 $j-w_i$ 时的最大价值， $dp(i,j)=dp(i-1, j-w_i) + v_i$

对于第 $i$ 个物品来说，只有放或者不放两种可能，因此最大价值只要取更大的一种可能就行。状态转移公式：
$$
dp(i, j) = max(dp(i-1, j), dp(i-1, j-w_i))
$$
可以直接使用二维数组记录状态 dp

```python
for i in range(1, n+1):
    for j in range(1, W+1):
        if j < w[i]:
            dp[i][j] = dp[i-1][j]
        else:
            dp[i][j] = max(dp[i-1, j], dp[i-1, j-w[i]] + v[i])
```

观察上述的转移方程，可以发现当前 dp 的状态只和前 i-1 件物品有关，即影响 $dp(i,.)$ 的只有 $dp(i-1, .)$ 。因此没有必要使用二维数组记录前面所有的状态，只需要一维数组即可。

```python
for i in range(1, n+1):
    for j in range(W, w[i]-1, -1):
        dp[j] = max(dp[j], dp[j-w[i]] + v[i])
```

需要注意，此时第二个 for 循环是 reverse 的，原因在于当前状态位置 j 需要借助上一个状态位置 j-w[i] 的信息，因此需要从尾部开始更新，否则会将前一个状态的信息提前覆盖，计算出错。


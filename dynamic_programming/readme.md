# 基础

## 最长公共子序列

**例题**： [leetcode 1143](https://leetcode-cn.com/problems/longest-common-subsequence/)

给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列的长度。若这两个字符串没有公共子序列，则返回 0。

>  一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。
> 例如，"ace" 是 "abcde" 的子序列，但 "aec" 不是 "abcde" 的子序列。两个字符串的「公共子序列」是这两个字符串所共同拥有的子序列。

示例：

```
输入: text1 = "abcde", text2 = "ace"
输出: 3

输入: text1 = "abc", text2 = "def"
输出: 0
```

**思路**：

需要找到当前状态和之前状态之间的递推关系，用 dp 表示状态数组。

* 例如对于样例 abcde 和 ace 的解，发现两个字符串的最后一个都是 e。因此对于 abcd 和 ac 的最长公共子序列，只要加上 e 就是 abcde 和 ace 的解，即 `dp[i,j] = dp[i-1][j-1]`
* 如果当前状态的两个字符不相同，例如 abcd 和 abdc。发现 abcd 和 abd 的最长子序列是 3，abd 末尾加字符 c 不改变结果。另一方面，abc 和 abdc 的最长子序列是 3，abc 末尾补上 d 不改变结果。因此当前状态取决于 `dp[i-1, j]` 和 `dp[i, j-1]`

综上，判断逻辑如下：

```python
if text1[i-1] == text2[j-1]:
    dp[i][j] = dp[i-1][j-1] + 1
else:
    dp[i][j] = max(dp[i-1][j], dp[i][j-1])
```

代码见 [1143](./最长公共子序列/1143.py)



# 背包

## 01背包

**典型例题**：

有 n 个物品和一个总承重量为 W 的背包，每个物品有重量 $ w_i $ 和价值 $ v_i $ 两种属性，要求选若干物品放入背包使背包中物品的总价值最大且背包中物品的总重量不超过背包的承重。

**思路**：

假设考虑前 $i$ 个物品和 $j$ 容量时的背包最大价值为 $dp(i,j)$ ，考虑递推关系，对于当前最大价值，有两种情况：

* 不放第 $i$ 个物品，因此与前 $i-1$ 个物品的最大价值相同， $dp(i,j) = dp(i-1,j)$
* 放第 $i$ 个物品，因此价值为前 $i-1$ 个物品在背包重量为 $j-w_i$ 时的最大价值， $dp(i,j)=dp(i-1, j-w_i) + v_i$

对于第 $i$ 个物品来说，只有放或者不放两种可能，因此最大价值只要取更大的一种可能就行。状态转移公式：
$$
dp(i, j) = max(dp(i-1, j), dp(i-1, j-w_i))
$$
可以直接使用二维数组记录状态 dp

```python
for i in range(1, n+1):
    for j in range(1, W+1):
        if j < w[i]:
            dp[i][j] = dp[i-1][j]
        else:
            dp[i][j] = max(dp[i-1, j], dp[i-1, j-w[i]] + v[i])
```

观察上述的转移方程，可以发现当前 dp 的状态只和前 i-1 件物品有关，即影响 $dp(i,.)$ 的只有 $dp(i-1, .)$ 。因此没有必要使用二维数组记录前面所有的状态，只需要一维数组即可。

```python
for i in range(1, n+1):
    for j in range(W, w[i]-1, -1):
        dp[j] = max(dp[j], dp[j-w[i]] + v[i])
```

需要注意，此时第二个 for 循环是 reverse 的，原因在于当前状态位置 j 需要借助上一个状态位置 j-w[i] 的信息，因此需要从尾部开始更新，否则会将前一个状态的信息提前覆盖，计算出错。

**例题**：[leetcode 416](https://leetcode-cn.com/problems/partition-equal-subset-sum/)

给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。

> 每个数组中的元素不会超过 100，数组的大小不会超过 200

示例如下：

```
输入: [1, 5, 11, 5]
输出: true
解释: 数组可以分割成 [1, 5, 5] 和 [11].

输入: [1, 2, 3, 5]
输出: false
解释: 数组不能分割成两个元素和相等的子集.
```

**思路**：

分成两个子集，元素和相等，相当于判断一个数组，不重复的选取一些元素，使得这些元素的和为数组总和的一半。

这种题一半有两种思路，第一种是回溯法，第二种就是使用动态规划。不同于一般的背包问题，本题使用回溯法会非常迅速，这是因为这道问题并不是判断最优解，而是判断可不可行（只要有一个解就行）。回溯的解法见[算法基础章节](../basic_algorithm/readme.md)









































